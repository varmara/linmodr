# Комментарии в текстах программ обозначаются символом #

# Полезные клавиатурные сокращения в RStudio:
# Ctrl + Shift + C - закомментировать/раскомментировать выделенный фрагмент кода
# Ctrl + Enter - отправляет строку из текстового редактора в консоль, а если выделить несколько строк, то будет выполнен этот фрагмент кода.
# Tab или Ctrl + Space - нажмите после того как начали набирать название функции или переменной, и появится список автоподстановки. Это помогает печатать код быстро и с меньшим количеством ошибок.

# Устанавливаем рабочую директорию
# Способы установки пути к рабочей директории:
  # 1) Выберите в меню Session -> Set working Directory... -> To Source File Location (Если вы уже сохранили код).
  # 2) На вкладке Files в одной из рабочих областей RStudio выберите многоточие ... -> в открывшемся системном диалоге выбора файлов найдите директорию, в которой лежит ваш код и нажмите OK
# 3) Можно вручную прописать путь к рабочей директории в кавычках в качестве аргумента функции setwd
# setwd("/media/data/ProjectsWork/lect-linmodr-2015/w1-Intro")

# Получаем помощь
# 1) В RStudio можно поставить курсор на слово setwd и нажать F1
# 2) Перед названием функции можно напечатать знак вопроса и выполнить эту строку
?setwd
# 3) Можно воспользоваться функцией help()
help("setwd")

# R как калькулятор, математические операции
2+2
1024/2
1:10
34*4
2^4
sqrt(27)

# Переменные, присвоение
# Оператор присваивания это символ стрелочки <-
# Он работает справа налево, это значит, что значение выражения в его правой части присваивается объекту в левой части.
# Переменные - это такие контейнеры, в которые можно положить разные данные и даже функции.
# Имена переменных могут содержать латинские буквы обоих регистров, символы точки . и подчеркивания _ , а так же цифры. Имена переменных должны начинаться с латинских букв. Создавайте понятные и "говорящие" имена переменных.
var_1 <- 1024 / 2
1238 * 3 -> var_2
var_2

# Кстати о названиях
# a - плохо, и даже b, с, или х. Но в некоторых случаях допустимо:)
# var1 - плохо, но уже лучше
# var_1 - плохо, но уже лучше
# shelllength - говорящее, но плохо читается
# shell_length, wing_colour или leg_num - хорошие говорящие и читабельные названия

# Структуры данных
# Данные в R можно хранить в виде разных объектов.
# В результате выполнения следующих команд получаются скалярные величины. Просто числа. Одно выражение - одно значение
23
sqrt(25)
# Векторы - один объект, внутри которого несколько значений.

# Способы создания векторов:
# 1) Оператор: используется для создания целочисленных векторов, где значения следуют одно за другим без пропусков
1:10 # от одного до 10
-5:3 # от -5 до 3

# 2) Функция c() - от англ. concatenate. Следите, чтобы было английское си, а не русское эс:).
?c
# Функция c принимает несколько (произвольное количество) аргументов, разделенных запятыми. Она собирает из них вектор.
c(2, 4, 6)
с(-9.3, 0, 2.17, 21.3)


# Векторы можно хранить в переменных для последующего использования
vect_num <- -11:12 # численный вектор от -11 до 12 сохранен в переменной vect_num
vect_num_1 <- c(1.3, 1.7, 1.2, 0.9, 1.6, 1.4) # численный вектор, сохранен в переменной vect_num_1

# Адресация внутри векторов
# При помощи оператора [], мужно обратится к некоторым элементам вектора.
# В квадратных скобках вам нужно указать один или несколько порядковых номеров элементов
vect_num[1] # первый элемент
vect_num[10] # 10-й элемент
vect_num[22]

# Если вам нужно несколько элементов, то их нужно передать квадратным скобкам в виде вектора.
# Например, нам нужны элементы с 3 по 5.
# Вот вектор, который содержит значения 3, 4 и 5.
3:5
# Если мы его напишем в квадратных скобках, то добудем элементы с такими порядковыми номерами
vect_num[3:5]

# Аналогично, если вам нужны элементы не подряд, то передайте вектор с номерами элементов, который вы создали при помощи функции c()
c(2, 4, 6) # это вектор содержащий 2, 4 и 6
# поэтому
vect_num[c(2, 4, 6)] # возвращает 2-й, 4-й и 6-й элементы
vect_num[c(1, 10, 20)] # возвращает 1-й, 10-й и 20-й элементы

# Вектор - одномерный объект. У его элементов только один порядковый номер (индекс). Поэтому при обращении к элементам вектора нужно указывать только одно число или один вектор с адресами.
# Правильно:
vect_num[c(1, 2, 5)] # возвращает 1-й, 3-й и 5-й элементы
# R выдаст ошибку, если при обращении к вектору, вы не создавали вектор, а просто перечислили номера элементов через запятую.
vect_num[1, 3, 5] # ошибка
vect_num[c(15, 9, 1)] # правильно
vect_num[15, 9, 1] # ошибка

# При помощи функции c() можно объединять несколько векторов и скаляров в один вектор
с(1, 1, 5:9)
c(vect_num, vect_num)
c(100, vect_num)

# добываем 1, 3, 5 и с 22 по 24 элементы
vect_num[c(1, 3, 5, 22:24)]

# Типы данных в R

# Числовые данные
# только что видели

# Текстовые данные
# Каждый текстовый элемент (говорят "строка" - string) должен быть окружен кавычками - двойными или одинарными
"это текст"
'это тоже текст'
# Текстовые значения можно объединять в вектора.
# Это текстовый вектор
rainbow <- c("red", "orange", "yellow", "green", "blue", "violet")
rainbow # весь вектор
# Добываем первый и последний элементы
# Я точно знаю, что их у меня 6, мне нужны 1 и 6.
rainbow[c(1, 6)]
# Добываем элементы с 3 по 6
# Если у вас вдруг слишком короткий вектор в этом задании, то можно склеить новый из двух
double_rainbow <- c(rainbow, rainbow)
double_rainbow
rainbow[3:6] # элементы с 3 по 6

# Логические данные
TRUE # истина
FALSE # ложь
# Для ленивых - можно сокращать первыми заглавными буквами. Но лучше так не делать, чтобы читать программы было легче
# c(T, T, T, T, F, F, T, T)
# Логический вектор
с(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)
# Еще логический вектор
short_logical_vector <- с(FALSE, TRUE)

# Создаем длинный логический вектор.
# Чтобы создавать длинные вектора из повторяющихся элементов, можно использовать функцию rep()
# ?rep
rep(x = 1, times = 3) # 1 повторяется 3 раза
rep(x = "red", times = 5) # "red" повторяется 5 раз
rep(x = TRUE, times = 2) # TRUE повторяется 2 раза
# В R названия аргументов функций можно не указывать, если вы используете аргументы в том же порядке, что прописан в help к этой функции.
rep(TRUE, 5) # TRUE повторяется 5 раз, аргументы без названий

# Создаем логический вектор, где TRUE повторяется 3 раза, FALSE 3 раза и TRUE 4 раза.
# Результат сохраняем в переменной vect_log
vect_log <- c(rep(TRUE, 3), rep(FALSE, 3), rep(TRUE, 4))
vect_log

# Факторы
# Факторы - это способ хранения дискретных (=категориальных данных). Например, если вы поймали 10 улиток и посмотрели их цвет. У большого количества улиток небольшое счетное количество возможных цветов.
snail_colours <- c("red", "green", "green", "green", "yellow", "yellow", "yellow", "yellow")
snail_colours # это текстовый вектор.
# Но цвет "желтый" обозначает одно и то же для каждой из улиток. Поэтому в целях экономии места можно записать цвета этих улиток в виде вектора, в котором численным значениям будут сопоставлены "этикетки" (называются "уровни" - levels) - названия цветов. Мы можем создать "фактор" цвет улиток.
factor(snail_colours)
# уровни этого фактора
# 1 - green,
# 2 - red,
# 3 - yellow
# По умолчанию, R назначает порядок уровней по алфавиту. Можно изменить порядок (см. help("factor")). Нам это пригодится позже

double_rainbow # текстовый вектор
# Создаем фактор из текстового вектора и складываем его в переменную
f_double_rainbow <- factor(double_rainbow)

# Как узнать, что за данные хранятся в переменной?
# Есть функция class()
class(f_double_rainbow)
class(vect_log)
class(vect_num)
class(rainbow)

# Встроенные константы в R
# NA, NULL, NAN, Inf
# NA - англ "not available". Когда объект был, но его свойство не измерили или не записали.
# NULL - пусто - просто ничего нет
# NaN - "not a number"
# Inf - "infinity" - бесконечность

# Вот текстовый вектор с пропущенным значением
rainbow_1 <- c("red", "orange", NA, "green", "blue", "violet")
# Кстати, если попросили добыть из вектора номер элемента, которого там точно нет, то R выдаст NA, потому, что такого элемента нет
rainbow_1[198]

# Поэкспериментируем с векторами. Проверим, как работают арифметические операции
vect_num + 2
vect_num * 2
vect_num * (-2)
vect_num ^2


# Теперь посмотрим на встроенные константы в действии.
# Создаем новый вектор для экспериментов
NAs_NANs <- c(1, 3, NA, 7, 0, 22:24)
# Вот так он выглядит
NAs_NANs

# Что произойдет с NA?
NAs_NANs + 2
NAs_NANs * 0
NAs_NANs / 0
0/0
sqrt(-1)

# Функции в R
# Вы уже видели массу функций, их легко узнать по скобкам после ключевого слова
# Познакомимся еще с несколькими и научимся писать пользовательские функции. Пользовательские функции позволяют автоматизировать повторяющиеся действия и делают код легко читаемым.

# Вот наш вектор
NAs_NANs
# Длину вектора можно вычислить при помощи функции length()
length(NAs_NANs)
# Сумму элементов вектора при помощи функции sum()
sum(NAs_NANs)
# Упс! Почему-то получилось NA
# Чтобы узнать, почему и как это исправить - посмотрите в help("sum")
# Выяснится, что у функции sum() есть аргумент na.rm, который по умолчанию принимает значение FALSE, то есть NA не учитываются при подсчете суммы.
# Если мы передадим функции sum аргумент na.rm = TRUE, то получится правильная сумма
sum(NAs_NANs, na.rm = TRUE)

# Теперь давайте попробуем вручную посчитать среднее значение элементов в векторе NAs_NANs и положить его в переменную
# Осторожно! В знаменателе должна быть не просто длина вектора, а число элементов, которые не равны NA
a <- sum(NAs_NANs, na.rm = TRUE) / (length(NAs_NANs) - 1)
a

# Проверяем при помощи встроенной функции mean()
mean(NAs_NANs)
# Она тоже не работает, если в векторе есть NA, но у нее тоже есть аргумент na.rm
mean(NAs_NANs, na.rm = TRUE)

# Попробуем написать пользовательскую функцию mmean(), которая будет по умолчанию считать среднее значение элементов в векторе с учетом пропущенных значений (NA)
mmean <- function(x){
  mean(x, na.rm = TRUE)
  }
# В этом коде:
# mmean - переменная, название функции. В эту переменную мы складываем функцию, которую создает функция function()
# function() - функция, которая делает функции. В скобках перечисляются аргументы (названия переменных, которые мы передаем в функцию, чтобы она что-то сделала с ними)
# { } - в фигурных скобках тело функции - последовательность действий, которую нужно сделать с аргументами
# У больших и толстых функций бывает еще инструкция return(), которая сообщает, что именно должна возвращать наша функция. Вот как выглядела бы наша функция с этой инструкцией
mmean <- function(x){
  res <- mean(x, na.rm = TRUE)
  return(res)
}

# Проверим нашу функцию при помощи встроенной функции
mean(vect_num, na.rm = TRUE)
mmean(vect_num)
# Работает


# Домашнее задание:
#   Упражнения для начинающих
# https://www.datacamp.com/courses
# Нужно зарегистрироваться, подписаться на курс Introduction to R, и пройти в нем самостоятельно главу 5 Dataframes
