---
title: "Линейные модели с непрерывными и дискретными предикторами"
subtitle    : "Линейные модели..."
author: Марина Варфоломеева, Вадим Хайтов
output:
  ioslides_presentation:
    widescreen: yes
    css: assets/my_styles.css
    logo: assets/Linmod_logo.png
---

```{r setup, include = FALSE, cache = FALSE, purl = FALSE}
# output options
options(width = 70, scipen = 6, digits = 3)
library(knitr)
# chunk default options
opts_chunk$set(fig.align='center', tidy = FALSE, fig.width = 7, fig.height = 3, warning = FALSE, cache = TRUE)
```

```{r libs-funs, echo=FALSE}
lm_equation <- function(fit, strict = TRUE, rnd = 2){
#   extracting call formula 
  frml <- as.character(fit$call)[2]
#   extract signs
    sign <- ifelse(grepl("-", coef(fit)[-1]), " - ", " + ")
  # extract coefficients
  coeffs <- format(round(abs(coef(fit)), rnd), digits = 2, trim = TRUE)
  if(strict == TRUE){
    i <- 1:(length(coeffs) - 1)
    vars <- c("Y", paste0(" X", i))
    
  } else {
# extract vector of variable names
  vars <- c(all.vars(formula(fit))[1], names(fit$coefficients)[-1])
# combine everything
  }
  start <- ifelse(coef(fit)[1] > 0, paste(vars[1], coeffs[1], sep = " = "), paste(vars[1], coeffs[1], sep = " = - "))
  end <- paste(sign, coeffs[-1], vars[-1], sep = "", collapse = "")
  return(cat(start, end, sep = ""))
}
```

## Мы рассмотрим

+ Линейные модели c непрерывными и дискретными предикторами
+ Простейший экспериментальный план, требующий анализа ковариации (ANCOVA)

### Вы сможете

+ Написать на языке R код, необходимый для подгонки линейной модели, включающей дискретные и непрерывные предикторы, а так же их взаимодействие
+ Дать трактовку коэффициентам такой линейной модели




## Пример: птицы в лесах Австралии

<div class="columns-2">

![forest in Victoria, Australia](images/vict_m.jpg)
<small>Mystic Forest - Warburton, Victoria by ¡kuba! on flickr</small>


<small>

56 лесных участков:

- ABUND - обилие птиц
- AREA - площадь участка
- YRISOL - год изоляции участка
- DIST - расстояние до ближайшего леса
- LDIST - расстояние до ближайшего большого леса
- GRAZE - пастбищная нагрузка (1-5)
- ALT - высота над уровнем моря

</small>

Эти данные мы уже анализировали, но предположим, что в фокусе нашего исследования зависимость обилия птиц (ABUND) от пастбищной нагрузки (GRAZE) и других ковариат. 

</div>

## Дискретный фактор
Переменная `GRAZE` по своей природе дискретна: балльная оценка с небольшим числом уровней

```{r}
BD <- read.csv("data/loyn.csv")
BD$fGRAZE <- factor(BD$GRAZE)
```

##Сбалансированная ли выборка по значениям дискретного фактора

```{r}
table(BD$fGRAZE)
```
Все более или менее ОК



## Есть ли наблюдения-выбросы? 
Строим dot-plot

```{r}
# "пустой график"
dot <- ggplot(data = BD, aes(y = 1:nrow(BD))) + geom_point()

```

## Есть ли наблюдения-выбросы? 
Строим dot-plot

```{r}
dot1 <- dot + aes(x = ABUND)
dot2 <- dot + aes(x = AREA)
dot3 <- dot + aes(x = YRISOL)
dot4 <- dot + aes(x = DIST)
dot5 <- dot + aes(x = LDIST)
dot6 <- dot + aes(x = ALT)
```

## Есть ли наблюдения-выбросы? 
Строим dot-plot
```{r, fig.height=5}
grid.arrange(dot1, dot2, dot3, dot4, dot5, dot6, ncol = 3)
```

## Преобразование предикторов
Ситуацию с отскакивающими точками можно исправить   
```{r}
BD$LOGAREA  <- log10(BD$AREA)
BD$LOGDIST  <- log10(BD$DIST)
BD$LOGLDIST <- log10(BD$LDIST)

```




## Проверяем на мультиколлинеарность

<small>

```{r}
library(car)
M0 <- lm(ABUND ~ LOGAREA + LOGDIST + LOGLDIST + YRISOL + ALT + fGRAZE, data = BD)

vif(M0)
```
</small>

## Проверяем на мультиколлинеарность
Поскольку `fGRAZE` - интересующий нас предиктор, то удалим из модели `YRISOL`
```{r}
M0.1 <- lm(ABUND ~ LOGAREA + LOGDIST + LOGLDIST + ALT + fGRAZE, data = BD)
vif(M0.1)
```
## Проверяем на мультиколлинеарность
```{r}
M0.2 <- lm(ABUND ~   LOGAREA + LOGDIST +  ALT + fGRAZE, data = BD)
vif(M0.2)
```


##Упрощаем модель
```{r}
M1 <- lm(ABUND ~   LOGAREA + LOGDIST +  ALT + fGRAZE, data = BD)
drop1(M1, test = "F")
```

##Упрощаем модель
```{r}
M2 <- update(M1, ~.- ALT)
drop1(M2, test = "F")
```



##Упрощаем модель
```{r}
M3 <- update(M2, ~.- LOGDIST)
drop1(M3, test = "F")
```

Больше ничего выбросить нельзя!

##Смотрим на результаты 

<small>
```{r}
summary(M3)
```

</small>

## Природа коэффициентов в линейной модели с дискретными предикторами

Запишем уравнение, описывающее связь обилия птиц с предикторами
<small>
```{r, echo=FALSE}
lm_equation(M3, strict = FALSE)
```

</small>

## Природа коэффициентов в линейной модели с дискретными предикторами

При включении в модель дискретных предикторов их уровни кодируются при помощи числовых переменных-болванок (dummy variables) 

Переменных болванок нужно на одну меньше, чем число уровней фактора

Для каждого из объектов каждая из болванок принимает значение 1 для своего уровня фактора

## Природа коэффициентов в линейной модели с дискретными предикторами

```{r}
X <- model.matrix(M3)
head(X, 10)
```
`fGRAZE1` отсутствует, он взят за базовый уровень 


##Задание: 
Найдите коэффициенты линейной модели с использованием матричной алгебры

## Решение

$$
\pmb{\beta} = [\textbf{X}'\textbf{X}]^{-1}[\textbf{X}'\textbf{y}]
$$


```{r}
betas <- solve(t(X)%*% X) %*% (t(X) %*% BD$ABUND)
betas
```



##Трактовка коэффциентов:

- $b_0 =$ `r round(coef(M3)[1], 2)` - интерцепт, обилие птиц __на базовом уровне (при `fGRAZE` = 1)__, если `LOGAREA` = 0.

Общий угол наклона:

- $b_1 =$ `r round(coef(M3)[2], 2)` - на столько особей увеличится численность птиц при любом уровне выпаса при увеличении логарифма площади на единицу

Для остальных уровней выпаса:

- $b_2 =$ `r round(coef(M3)[3], 2)` - отличие обилия птиц при `fGRAZE` = 2 от обилия птиц при `fGRAZE` = 1
- $b_3 =$ `r round(coef(M3)[4], 2)` - отличие обилия птиц при `fGRAZE` = 3 от обилия птиц при `fGRAZE` = 1

и т.д.

## Задание. 
Запишите уравнение, описывающее связь между обилием птиц и `LOGAREA`  для каждого уровня выпаса

##Решение

<small>

Общее уравнение модели с параллельными линиями:   

```{r, echo=FALSE, results='asis'}
lm_equation(M3, strict = FALSE, rnd = 3)
```

Для `fGRAZE` = 1:   
ABUND = 15.72 + 7.25LOGAREA 

Для `fGRAZE` = 2:   
ABUND = 15.72 + 7.25LOGAREA + 0.38 = (15.72 + 0.38) + 7.25LOGAREA  

Для `fGRAZE` = 3:   
ABUND = 15.72 + 7.25LOGAREA - 0.19 = (15.72 - 0.19) + 7.25LOGAREA

</small>
и т.д.

## Базовый уровень

Уровень дискретного предиктора, для записи которого мы не использовали отдельную переменную-болванку, называется базовым.

Интерцепт в уравнении регрессии описывает среднее значение предиктора на базовом уровне.

В `R` базовым уровнем считается первый уровень фактора (обычно первый по алфавиту)

```{r}
  levels(BD$fGRAZE)
```

В данном случае это уровень "1"

## Что произойдет с моделью, если мы изменим базовый уровень? {.smaller}

```{r}
BD$fGRAZE <- relevel(BD$fGRAZE, ref = "5")
levels(BD$fGRAZE) # Теперь первым идет "5"
```
```{r}
M3_ref_5 <- lm(formula = formula(M3), data = BD)
summary(M3_ref_5)
```

## Изменился ли смысл модели от смены уровней? 

<small>

```{r, echo=FALSE, results='asis'}
lm_equation(M3_ref_5, strict = FALSE, rnd = 3)
```

Для `fGRAZE` = 1:

было: ABUND = 15.72 + 7.25LOGAREA 

стало: ABUND = 3.8 + 7.2LOGAREA + 11.9 = 15.7 + 7.2LOGAREA


Для `fGRAZE` = 2:

было: ABUND = 16.1 + 7.25LOGAREA

стало: ABUND = 3.8 + 7.2LOGAREA + 12.3 = 16.1 + 7.2LOGAREA 

и т.д.

</small>


### Модели остались неизменными!

## Строим график модели с одинаковыми углами наклона 

Нужны исходные данные с предсказанными значениями и стандартными ошибками. При этом хорошо бы, чтобы диапазоны предикторов для каждого из уровней дискретной переменной соответствовали реальным значениям.

## Строим график модели с одинаковыми углами наклона 

Решение привычными методами:

```{r}
my_df <- expand.grid(
  fGRAZE = unique(BD$fGRAZE), 
  LOGAREA = seq(min(BD$LOGAREA), max(BD$LOGAREA), 0.1 )
  )
my_df$Predicted <- predict(M3, newdata = my_df)
my_df$SE <- predict(M3, newdata = my_df, se.fit = TRUE)$se.fit

```

## Строим график модели с одинаковыми углами наклона 


Решение средствами пакета `dplyr`:

```{r, eval=FALSE, tidy=FALSE}
library(dplyr)

# Конвейерный принцип обработки данных 

minmax <- BD %>% group_by(fGRAZE) %>% #Передаем датафрейм функции group_by()
  summarise(minAREA = min(LOGAREA),
  maxAREA = max(LOGAREA)) #Передаем функции summarise()

# Pазбиваем minmax по переменной GRAZE создаем датафрейм, 
# где LOGAREA - это последовательность от минимума до максимума для данного fGRAZE,
# снимаем группировку,
# добавляем предсказанные значения и стандартные ошибки

my_df2 <- minmax %>% group_by(fGRAZE) %>% 
  do(data.frame(LOGAREA = seq(.$minAREA, .$maxAREA, length = 10))) %>% 
  ungroup %>% 
  mutate(Predicted = predict(M3, newdata = .),
    SE = predict(M3, newdata = ., se.fit = TRUE)$'se.fit')
```

## Строим график с параллельными прямыми

Какой вариант правльный?
```{r, tidy=FALSE, fig.height=5, echo=FALSE}
gg_parallel1 <- ggplot(data = my_df, aes(y = Predicted, x = LOGAREA, colour = fGRAZE, fill = fGRAZE)) +  
  geom_path() + 
  geom_ribbon(aes(ymax = Predicted + 1.98 * SE, 
                  ymin = Predicted - 1.98 * SE),
              alpha = 0.3, colour = NA) +
    geom_point(data = BD, aes(x = LOGAREA, y = ABUND)) +
  labs(colour = "Уровень выпаса", fill = "Уровень выпаса", 
       x = "Логарифм площади",
       y = "Обилие птиц") + ggtitle("Наша модель") + 
  theme(text = element_text(size = 10) )


gg_parallel2 <- ggplot(data = my_df2, aes(y = Predicted, x = LOGAREA, colour = fGRAZE, fill = fGRAZE)) +  
  geom_line() + 
  geom_ribbon(aes(ymax = Predicted + 1.98 * SE, 
                  ymin = Predicted - 1.98 * SE),
              alpha = 0.3, colour = NA) +
    geom_point(data = BD, aes(x = LOGAREA, y = ABUND)) +
  labs(colour = "Уровень выпаса", fill = "Уровень выпаса", 
       x = "Логарифм площади",
       y = "Обилие птиц") + ggtitle("Наша модель") + 
  theme(text = element_text(size = 10) )


gg_initial <- ggplot(data = BD, aes(x = LOGAREA, y = ABUND, color = fGRAZE)) + geom_point() + geom_smooth(method = "lm") + ggtitle("По сырым данным")  + 
  theme(text = element_text(size = 10) )


grid.arrange(gg_parallel1, gg_parallel2, ncol = 2)
```

## Строим график с параллельными прямыми

Вторым методом получилось более строго, так как "обрезанные" графики не дают возможности для экстраполяций 

```{r}
grid.arrange(gg_parallel1, gg_parallel2, ncol = 2)
```



## Сравним модель с "сырыми данными"

```{r, echo=FALSE, fig.height=5, fig.width=9}
grid.arrange(gg_parallel2, gg_initial, ncol = 2)
```


## Может быть линии на самом деле не параллельны? 

### Мы должны были начать именно с этой, полной, модели

Чтобы проверить, одинаковы ли зависимости для каждого из участков, нам нужно подобрать модель со взаимодействием и протестировать его значимость.

```{r}
M4 <- lm(ABUND ~ (LOGAREA + LOGDIST +  ALT + fGRAZE)^2, data = BD)
```

Эта запись говорит о том, что в модель включаются только взаимодействия второго уровня

##Упрощаем модель
```{r}
drop1(M4, test = "F")
```


##Упрощаем модель
```{r}
M5 <- update(M4, ~.-LOGAREA:LOGDIST )
drop1(M5, test = "F")
```


##Упрощаем модель
```{r}
M6 <- update(M5, ~.-LOGDIST:fGRAZE )
drop1(M6, test = "F")
```



##Упрощаем модель
```{r}
M7 <- update(M6, ~.-ALT:fGRAZE)
drop1(M7, test = "F")
```

##Упрощаем модель
```{r}
M8 <- update(M7, ~.-LOGDIST:ALT)
drop1(M8, test = "F")
```

##Упрощаем модель
```{r}
M9 <- update(M8, ~.-LOGDIST)
drop1(M9, test = "F")
```



##Упрощаем модель
```{r}
M10 <- update(M9, ~.-LOGAREA:ALT)
drop1(M10, test = "F")
```


##Упрощаем модель
```{r}
M11 <- update(M10, ~.-ALT)
drop1(M11, test = "F")
```


##Упрощаем модель
```{r}
M12 <- update(M11, ~.-LOGAREA:fGRAZE )
drop1(M12, test = "F")
```


##Финальная модель

<small>
```{r, echo=FALSE}
lm_equation(M12, strict = FALSE)
```

</small>

### Наличие взаимодействия не было доказано!



## Не забываем, что полученную модель надо еще проверить на условия применимости.

```{r, echo=FALSE, fig.height=5}
library(car)
op <- par(mfrow = c(1, 1)) # располагаем картинки в 3 колонки
par(mfrow = c(1, 3))
plot(M12, which = 4)          # Расстояние Кука
residualPlot(M12)             # График остатков
qqPlot(M12)                   # Квантильный график остатков
par(op) 
```



## А если по условиям задачи нас все-таки интересуют взаимодействия? 

### Проверим по AIC какая модель лучше 

```{r}
formula(M12)
```

```{r}
formula(M11)
```


```{r}
AIC(M12, M11)
```

Введение взаимодействия немного улучшает модель!



## Строим график модели с разными углами наклона 

```{r}
my_df <- unique(BD[, c("fGRAZE", "LOGAREA")]) # еще один метод
  
my_df$Predicted <- predict(M11, newdata = my_df)
my_df$SE <- predict(M11, newdata = my_df, se.fit = TRUE)$se.fit

```


```{r, echo=FALSE, fig.height=4, fig.width=9}
gg_not_parallel <- ggplot(data = my_df, aes(y = Predicted, x = LOGAREA, colour = fGRAZE, fill = fGRAZE)) +  
  geom_line() + 
  geom_ribbon(aes(ymax = Predicted + 1.98 * SE, 
                  ymin = Predicted - 1.98 * SE),
              alpha = 0.3, colour = NA) +
    geom_point(data = BD, aes(x = LOGAREA, y = ABUND)) +
  labs(colour = "Уровень выпаса", fill = "Уровень выпаса", 
       x = "Логарифм площади",
       y = "Обилие птиц") + ggtitle("Модель со взаимодействиями") + 
  theme(text = element_text(size = 10) )

grid.arrange(gg_parallel2, gg_not_parallel, ncol = 2)
```

## Как охарактеризовать результат в статье?
```{r}
anova(M11)
```

## Пример: Козы и глисты

Как влияет на прирост массы коз интенсивность профилактики паразитарных заболеваний?

<div class="columns-2">

<img src="images/Goat-by-Jennifer-C.-Flickr.jpg" width="300" height="300">   
<small> Goat by Jennifer C. [on Flickr](https://flic.kr/p/fjU4J9) </small>  


Известно, что у легких животных привес больше, поэтому мы должны учитывать в модели не только способ обработки от глистов, но и влияние начального веса.


- Treatment - обработка от глистов (стандартная, интенсивная)
- Weightgain - привес, кг
- Initial.wt - начальный вес, кг


</div>

<small>
<div class=.footnote>Пример из библиотеки данных   
http://www.statlab.uni-heidelberg.de/data/ancova/goats.story.html</div>

</small>

## Читаем и знакомимся с данными

```{r}
goat <- read.delim("data/goats.csv")
str(goat)
# переименуем переменные для краткости
colnames(goat) <- c("treat", "wt", "init")
any(is.na(goat))
table(goat$treat)
```

## Проверим порядок уровней фактора
```{r}
levels(goat$treat)
```

Хорошо бы поменять их местами для удобства интерпретации

```{r}
goat$treat <- relevel(goat$treat, ref = "standard")
```

## Задание

1. Подберите модель, описывающую зависимость между увеличением веса коз и способом прфилактической обработки животных.
2. Проверьте условия применимости этой модели
3. Попробуйте сократить модель, чтобы она стала оптимальной.
4. Проверьте условия применимости финальной модели.

## Решение

Необходимо учитывать ковариату - начальный вес, кроме того, нужно проверить, нет ли взаимодействия способа обработки от глистов и начального веса

```{r}
MG1 <- lm(wt ~ treat * init, data = goat)
```

Формула модели со взаимодействием выглядит в сокращенном виде так:

```{r echo=FALSE, results='asis'}
formula(MG1)
```

а в полном виде то же самое выглядит так:

```{r echo=FALSE, results='asis'}
full_fact <- function(fit, nways = 2){
  vars <- all.vars(formula(fit))
  if(nways > length(vars) - 1 | nways <= 0) {
    stop("nways should be a positive number less or equal to the number of predictors")
  } 
  pred <- vars[-1]
  for (i in 2:nways) {
    pred <- c(pred, paste(combn(vars[-1], 1), collapse = ":"))
  }
  frm <- paste(vars[1], paste(pred, collapse = " + "), sep = " ~ ")
  return(frm)
}
cat(full_fact(fit = MG1, nways = 2))
```

## График модели со взаимодействием

Похоже, что взаимодействие не будет достоверным. 

```{r}
gg_g <- ggplot(data = goat, aes(y = wt, x = init, colour = treat)) + 
  geom_point()  +
  labs(x = "Начальный вес, кг",
       y = "Привес, кг") +
  scale_colour_discrete("Способ обработки", breaks = c("intensive", "standard"), labels = c("Интенсивный", "Стандартный"))
gg_g + geom_smooth(method = "lm")
```

## Проверяем условия применимости

```{r, fig.show='hold', fig.height=3.5, fig.width=10}
op <- par(mfrow = c(1, 3), cex = 1)
qqPlot(MG1)
plot(MG1, which = 3)
plot(MG1, which = 4)
par(op)
```

Все хорошо

## Выбор оптимальной модели

Пробуем удалить взаимодействие

```{r}
drop1(MG1, test = "F")
```

Можно удалять

## Удаляем взаимодействие и пробуем упростить дальше

```{r}
MG2 <- update(MG1, .~. - treat:init)
drop1(MG2, test = "F")
```

Дальше упростить не получится. Вот наша оптимальная модель

## Проверяем условия применимости финальной модели

```{r, fig.show='hold', fig.height=3.5, fig.width=10}
op <- par(mfrow = c(1, 3), cex = 1)
qqPlot(MG2)
plot(MG2, which = 3)
plot(MG2, which = 4)
par(op)
```

Все в порядке

## Проверяем значимость коэффициентов

```{r}
summary(MG2)
```

## Записываем уравнение модели

```{r}
coef(MG2)
```
Уравнение:

```{r echo=FALSE,results='asis'}
lm_equation(MG2, strict = FALSE)
```

Привес коз при интенсивной обработке от глистов на 1.26 кг выше, чем при стандартном методе обработки (t-тест, p < 0.05)


## Take home messages

- Коэффициенты регрессии при дискретных предикторах позволяют сопоставить средние значения для каждого уровня фактора со средним значением для базового уровня.
- При изменении базового уровня, коэффициенты изменятся, но суть модели останется той же.
- В одной модели можно объединить как непрерывные, так и дискретные предикторы.
- При анализе экспериментальных данных, включение в анализ некоторых ковариат может помочь лучше увидеть закономерности.


## Что почитать
+ Quinn G.P., Keough M.J. (2002) Experimental design and data analysis for biologists, `Chapter 12`.
